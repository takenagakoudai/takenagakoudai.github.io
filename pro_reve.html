<!DOCTYPE html>
<html dir="ltr" lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=yes, maximum-scale=1.0, minimum-scale=1.0">
<title>subpage</title>
<meta name="keywords" content="">
<meta name="description" content="">
<link rel="stylesheet" href="style.css" type="text/css" media="screen">
<!--[if lt IE 9]>
<script src="js/html5.js"></script>
<script src="js/css3-mediaqueries.js"></script>
<![endif]-->
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="js/jquery1.7.2.min.js"></script>
<script src="js/script.js"></script>
</head>
<body>

<header id="header" role="banner">
	<div class="inner">
		<h1>九州大学　理学部　数学科</h1>
		<h2><a href="index.html">竹永　耕大　のHP</a></h2>
	</div>
</header>

<nav id="mainNav">
	<div class="inner">
		<a class="menu" id="menu"><span>MENU</span></a>
		<div class="panel">
			<ul>
				<li><a href="sub_univ.html"><strong>大学での成果</strong><span>university</span></a></li>
				<li><a href="sub_math.html"><strong>数学と日常</strong><span>math and everydy</span></a></li>
				<li><a href="sub_past.html"><strong>　過去問　</strong><span>past paper</span></a></li>
				<li><a href="sub_prob.html"><strong>その他問題集</strong><span>problems</span></a></li>
				<li><a href="sub_info.html"><strong>　情報　</strong><span>information</span></a></li>
				<li><a href="sub_othe.html"><strong>　その他　</strong><span>others</span></a>
					<ul class="sub-menu">
						<li><a href="https://www.skaji.org">鍛冶先生HP</a></li>
						<li><a href="https://ryokawai-github.github.io/website/">河井さんHP</a></li>
						<li><a >あはは</a></li>
					</ul>
				</li>
			</ul>
		</div>
	</div>
</nav>

<div id="wrapper">

	<div id="content2">
		<section>
			<article class="content2">
				<header>
					<h2 class="title first"><span>目次</span></h2>
				</header>
				<div class="post">
					オセロのソースコードです．C言語で書いています．
					<h3>ソースコード</h3>
<pre><code class="prettyprint linenums">
	#include&lt;stdio.h&gt;
	#include&lt;stdlib.h&gt;

	//盤のサイズ
	#define SIZE 8
	#define WIDTH SIZE
	#define HEIGHT SIZE

	//==================================================
	// enum:列挙型・・定義されたメンバの順に0から整数値がつけられる． =
	//    石の色の例では， white=0..  となる                 =
	//    main関数内以下で1がプリントされる                   =
	//int main(){                                      =
	//  COLOR white;                                   =
	//  printf(&quot;%d\n&quot;,white);                          =
	//}                                                =
	//==================================================
	//石の色
	typedef enum color{
	  white,black,empty
	} COLOR;

	//石を置けるかの判断
	typedef enum put{
	  ok,ng
	} PUT;

	//盤を表す二次元配列
	COLOR b[HEIGHT][WIDTH];
	//検査用二次元配列
	COLOR c[HEIGHT][WIDTH];
	COLOR d[HEIGHT][WIDTH];
	//評価用二次元配列
	int ev1[8][8]={
	  {120,-20,20,5,5,20,-20,120},
	  {-20,-40,-5,-5,-5,-5,-40,-20},
	  {20,-5,15,3,3,15,-5,20},
	  {5,-5,3,3,3,3,-5,5},
	  {5,-5,3,3,3,3,-5,5},
	  {20,-5,15,3,3,15,-5,20},
	  {-20,-40,-5,-5,-5,-5,-40,-20},
	  {120,-20,20,5,5,20,-20,120},
	};
	int ev2[8][8]={
	  {30,-12,0,-1,-1,0,-12,30},
	  {-12,-15,-3,-3,-3,-3,-15,-12},
	  {0,-3,0,-1,-1,0,-3,0},
	  {-1,-3,-1,-1,-1,-1,-3,-1},
	  {-1,-3,-1,-1,-1,-1,-3,-1},
	  {0,-3,0,-1,-1,0,-3,0},
	  {-12,-15,-3,-3,-3,-3,-15,-12},
	  {30,-12,0,-1,-1,0,-12,30}
	};



	//盤の初期化
	int init(){
	  unsigned char x,y;     //usingned char 型:1バイトの符号なし整数(0~255)の値を記憶可能
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      b[y][x]=empty;
	    }
	  }
	  //初期配置
	  b[HEIGHT/2][WIDTH/2]=white;
	  b[HEIGHT/2-1][WIDTH/2-1]=white;
	  b[HEIGHT/2-1][WIDTH/2]=black;
	  b[HEIGHT/2][WIDTH/2-1]=black;
	  return 0;
	}

	//マス表示
	int displaysquare(COLOR square){
	  switch(square){  //switch文:多方向分岐
	    case white:
	     printf(&quot;o|&quot;);
	     break;
	    case black:
	     printf(&quot;*|&quot;);
	     break;
	    case empty:
	     printf(&quot; |&quot;);
	     break;
	    default:
	     printf(&quot;エラー&quot;);
	     return -1;
	  }
	  return 0;
	}

	//盤の表示
	int display(){
	  int x,y;
	  for(y=0;y&lt;HEIGHT;y++){
	    //横方向のマス番号表示
	    if(y==0){
	      printf(&quot; |&quot;);
	      for(x=0;x&lt;WIDTH;x++){
	        printf(&quot;%d|&quot;,x);
	      }
	      printf(&quot;\n&quot;);
	    }
	    for(x=0;x&lt;WIDTH;x++){
	      //縦方向のマス番号表示
	      if(x==0){
	        printf(&quot;%d|&quot;,y);
	      }
	      //盤に置かれた石情報表示
	      displaysquare(b[y][x]);
	    }
	    printf(&quot;\n&quot;);
	  }
	  return 0;
	}

	//指定された場所に石を置く
	int put(int x,int y,COLOR color){
	  int i,j,s,n;
	  COLOR other;
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  else{
	    return -1;
	  }
	  //全方向に対して挟んだ石をひっくり返す
	  //全8方向確認
	  for(j=-1;j&lt;2;j++){
	    for(i=-1;i&lt;2;i++){
	      if(i==0&amp;&amp;j==0){//置いた場所なので確認なし．
	        continue;
	      }
	      if(b[y+j][x+i]!=other){//隣が相手の色でなければその方向ではひっくり返せない
	        continue;
	      }
	      //置いた場所から遠い方向へ1マスずつ確認
	      for(s=2;s&lt;SIZE;s++){
	        //盤面外の除外
	        if(x+i*s&gt;=0&amp;&amp;x+i*s&lt;WIDTH&amp;&amp;y+j*s&gt;=0&amp;&amp;y+j*s&lt;HEIGHT){
	          if(b[y+j*s][x+i*s]==empty){
	            //自分の石発見前に空き
	            break;;
	          }
	          if(b[y+j*s][x+i*s]==color){
	            //自分の石発見
	            b[y][x]=color;
	            for(n=1;n&lt;s;n++){
	              //挟んだ石をひっくり返す
	              for(n=1;n&lt;s;n++){
	                b[y+j*n][x+i*n]=color;
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	  return 0;
	}

	//指定された場所に置けるかの判断
	PUT isputtable(int x,int y,COLOR color){
	  int i,j,s,count;
	  COLOR other;
	  //空でなければおけない
	  if(b[y][x]!=empty){
	    return ng;
	  }
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  else{
	    return ng;
	  }
	  //各方向に対し，そこに置くと相手の石がひっくり返せるか確認
	  //置ける石のカウント
	  count=0;
	  for(j=-1;j&lt;2;j++){
	    for(i=-1;i&lt;2;i++){
	      //置いた場所は飛ばす
	      if(i==0&amp;&amp;j==0){
	        continue;
	      }
	      //隣が相手の色でなければその方向ではひっくり返せない
	      if(b[y+j][x+i]!=other){
	        continue;
	      }
	      //置こうとしているマスから遠い方向へ確認
	      for(s=2;s&lt;SIZE;s++){
	        //盤面街の除外
	        if(x+i*s&gt;=0&amp;&amp;x+i*s&lt;WIDTH&amp;&amp;y+j*s&gt;=0&amp;&amp;y+j*s&lt;HEIGHT){
	          if(b[y+j*s][x+i*s]==empty){
	            //自分の石が見つかる前に空きある場合
	            break;;
	          }
	          if(b[y+j*s][x+i*s]==color){
	            //ひっくり返せる石のカウント
	            count++;
	          }
	        }
	      }
	    }
	  }
	  if(count==0){
	    return ng;
	  }
	  return ok;
	}

	//指定された場所に石を置く検証
	int put_investigate(int x,int y,COLOR color){
	  int i,j,s,n;
	  COLOR other;
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  else{
	    return -1;
	  }
	  //全方向に対して挟んだ石をひっくり返す
	  //全8方向確認
	  for(j=-1;j&lt;2;j++){
	    for(i=-1;i&lt;2;i++){
	      if(i==0&amp;&amp;j==0){//置いた場所なので確認なし．
	        continue;
	      }
	      if(c[y+j][x+i]!=other){//隣が相手の色でなければその方向ではひっくり返せない
	        continue;
	      }
	      //置いた場所から遠い方向へ1マスずつ確認
	      for(s=2;s&lt;SIZE;s++){
	        //盤面外の除外
	        if(x+i*s&gt;=0&amp;&amp;x+i*s&lt;WIDTH&amp;&amp;y+j*s&gt;=0&amp;&amp;y+j*s&lt;HEIGHT){
	          if(c[y+j*s][x+i*s]==empty){
	            //自分の石発見前に空き
	            break;;
	          }
	          if(c[y+j*s][x+i*s]==color){
	            //自分の石発見
	            c[y][x]=color;
	            for(n=1;n&lt;s;n++){
	              //挟んだ石をひっくり返す
	              for(n=1;n&lt;s;n++){
	                c[y+j*n][x+i*n]=color;
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	  return 0;
	}

	//指定された場所に置けるかの判断検証
	PUT isputtable_investigate(int x,int y,COLOR color){
	  int i,j,s,count;
	  COLOR other;
	  //空でなければおけない
	  if(c[y][x]!=empty){
	    return ng;
	  }
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  else{
	    return ng;
	  }
	  //各方向に対し，そこに置くと相手の石がひっくり返せるか確認
	  //置ける石のカウント
	  count=0;
	  for(j=-1;j&lt;2;j++){
	    for(i=-1;i&lt;2;i++){
	      //置いた場所は飛ばす
	      if(i==0&amp;&amp;j==0){
	        continue;
	      }
	      //隣が相手の色でなければその方向ではひっくり返せない
	      if(c[y+j][x+i]!=other){
	        continue;
	      }
	      //置こうとしているマスから遠い方向へ確認
	      for(s=2;s&lt;SIZE;s++){
	        //盤面街の除外
	        if(x+i*s&gt;=0&amp;&amp;x+i*s&lt;WIDTH&amp;&amp;y+j*s&gt;=0&amp;&amp;y+j*s&lt;HEIGHT){
	          if(c[y+j*s][x+i*s]==empty){
	            //自分の石が見つかる前に空きある場合
	            break;;
	          }
	          if(c[y+j*s][x+i*s]==color){
	            //ひっくり返せる石のカウント
	            count++;
	          }
	        }
	      }
	    }
	  }
	  if(count==0){
	    return ng;
	  }
	  return ok;
	}

	//ひっくり返せる数のカウント
	int count_investigate(int x,int y,COLOR color){
	  int i,j,s,count;
	  COLOR other;
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  count=0;
	  for(j=-1;j&lt;2;j++){
	    for(i=-1;i&lt;2;i++){
	      //置いた場所は飛ばす
	      if(i==0&amp;&amp;j==0){
	        continue;
	      }
	      //隣が相手の色でなければその方向ではひっくり返せない
	      if(c[y+j][x+i]!=other){
	        continue;
	      }
	      //置こうとしているマスから遠い方向へ確認
	      for(s=2;s&lt;SIZE;s++){
	        //盤面街の除外
	        if(x+i*s&gt;=0&amp;&amp;x+i*s&lt;WIDTH&amp;&amp;y+j*s&gt;=0&amp;&amp;y+j*s&lt;HEIGHT){
	          if(c[y+j*s][x+i*s]==empty){
	            //自分の石が見つかる前に空きある場合
	            break;;
	          }
	          if(c[y+j*s][x+i*s]==color){
	            //ひっくり返せる石のカウント
	            count++;
	          }
	        }
	      }
	    }
	  }
	  if(count==0){
	    return 0;
	  }
	  return count;
	}

	//相手の置ける場所のカウント
	int check_count(int x,int y,COLOR color){
	  int i,j,s,count;
	  COLOR other;
	  //相手の石の色
	  if(color==white){
	    other=black;
	  }
	  else if(color==black){
	    other=white;
	  }
	  count=0;
	  for(i=0;i&lt;WIDTH;i++){
	    for(j=0;j&lt;HEIGHT;j++){
	      if(isputtable_investigate(i,j,other)==ok){
	        count++;
	      }
	    }
	  }
	  return count;
	}


	//プレイヤーが石を置く
	void play(COLOR color){
	  int x,y;
	  //置く場所が決まるまで無限ループ
	  while(1){
	    printf(&quot;あなた:*  COM:o\n&quot;);
	    printf(&quot;横方向=&quot;);
	    scanf(&quot;%d&quot;,&amp;x);
	    printf(&quot;縦方向=&quot;);
	    scanf(&quot;%d&quot;,&amp;y);
	    //入力箇所が置けるならループ抜ける
	    if(isputtable(x,y,color)==ok){
	      break;
	    }
	    //入力された場所がおけない時の処理
	    printf(&quot;そこおけんって．\n&quot;);
	  }
	  //石を置く．
	  put(x,y,black);
	}

	//COMが石を置く　　　　　　ランダムにおいていく
	void com(COLOR color){
	  int x,y;
	  //置ける場所探索
	  while(1){
	    y=rand()%8;
	    x=rand()%8;
	    if(isputtable(x,y,color)==ok){
	      put(x,y,color);
	      printf(&quot;COMが(%d,%d)に石置いた．\n&quot;,x,y);
	      break;
	    }
	  }
	}

	//強いCOMを作りたい...　　　　少し考える．
	void com2(COLOR color,int count){
	  int x,y,n,m;
	  int i,j,k;
	  //置く場所探索
	  while(1){
	    //ストックする．
	    for(y=0;y&lt;HEIGHT;y++){
	      for(x=0;x&lt;WIDTH;x++){
	        c[y][x]=b[y][x];
	      }
	    }
	    if(isputtable_investigate(0,0,color)==ok){
	      i=0;j=0;
	    }
	    else if(isputtable_investigate(7,7,color)==ok){
	      i=7;j=7;
	    }
	    else if(isputtable_investigate(0,7,color)==ok){
	      i=0;j=7;
	    }
	    else if(isputtable_investigate(7,0,color)==ok){
	      i=7;j=0;
	    }
	    else if(count&lt;30){
	      n=10;
	      for(k=0;k&lt;1000;k++){
	        y=rand()%8;
	        x=rand()%8;
	        if(isputtable_investigate(x,y,color)==ok){
	          m=count_investigate(x,y,color);
	          if(n&gt;m){
	            n=m;
	            i=x;j=y;
	          }
	        }
	      }
	    }
	    else{
	      n=0;
	      for(k=0;k&lt;1000;k++){
	        y=rand()%8;
	        x=rand()%8;
	        if(isputtable_investigate(x,y,color)==ok){
	          m=count_investigate(x,y,color);
	          if(n&lt;m){
	            n=m;
	            i=x;j=y;
	          }
	        }
	      }
	    }

	    put(i,j,color);
	    printf(&quot;COMが(%d,%d)に石置いた．\n&quot;,i,j);
	    break;
	  }
	}

	//強いCOMを作りたい...Part2  相手が置けるマスを少なくなるようにおく．
	void com3(COLOR color,int count){
	  int x,y,n,m,p,q,r,l;
	  int i,j,k;
	  //置く場所探索
	  while(1){
	    //ストックする．
	    for(y=0;y&lt;HEIGHT;y++){
	      for(x=0;x&lt;WIDTH;x++){
	        c[y][x]=b[y][x];
	      }
	    }
	    q=20;
	    //角はとっときたい．
	    if(isputtable_investigate(0,0,color)==ok){
	      i=0;j=0;
	    }
	    else if(isputtable_investigate(7,7,color)==ok){
	      i=7;j=7;
	    }
	    else if(isputtable_investigate(0,7,color)==ok){
	      i=0;j=7;
	    }
	    else if(isputtable_investigate(7,0,color)==ok){
	      i=7;j=0;
	    }
	    //相手が置けるコマ数を最小にする．
	    else if(count&lt;50){
	      for(y=0;y&lt;HEIGHT;y++){
	        for(x=0;x&lt;WIDTH;x++){
	          //角から1つ内は取らないように
	          if((x==1&amp;&amp;y==1)||(x==1&amp;&amp;y==6)||(x==6&amp;&amp;y==1)||(x==6&amp;&amp;y==6)){
	            break;
	          }
	          else if(isputtable_investigate(y,x,color)==ok){
	            put_investigate(y,x,color);
	            p=check_count(y,x,color);
	            if(p&lt;q){
	              i=y;j=x;q=p;
	            }
	          }
	          //盤面リセット
	          for(r=0;r&lt;HEIGHT;r++){
	            for(l=0;l&lt;WIDTH;l++){
	              c[r][l]=b[r][l];
	            }
	          }
	        }
	      }
	    }

	    put(i,j,color);
	    printf(&quot;COMが(%d,%d)に石置いた．\n&quot;,i,j);
	    break;
	  }
	}

	//評価値を用いて作成
	void com4(COLOR color,int count){
	  int x,y,n,m,i,j,r,l;
	  int countP,countAI,countP_,countAI_;
	  int ev[8][8];
	  COLOR other;
	  if(color==white){
	    other=black;
	  }
	  else{
	    other=white;
	  }
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      ev[y][x]=ev2[y][x];
	    }
	  }
	  if(b[7][0]==other){
	    for(i=0;i&lt;4;i++){
	      ev[6-i][0]=-40+5*i;
	      ev[7][1+i]=-40+5*i;
	      ev[6-i][1+i]=-40+10*i;
	    }
	  }
	  if(b[0][7]==other){
	    for(i=0;i&lt;4;i++){
	      ev[1+i][7]=-40+5*i;
	      ev[0][6-i]=-40+5*i;
	      ev[1+i][6-i]=-40+10*i;
	    }
	  }
	  if(b[7][7]==other){
	    for(i=0;i&lt;4;i++){
	      ev[6-i][7]=-40+5*i;
	      ev[7][6-i]=-40+5*i;
	      ev[6-i][6-i]=-40+10*i;
	    }
	  }
	  if(b[0][0]==other){
	    for(i=0;i&lt;4;i++){
	      ev[1+i][0]=-40+5*i;
	      ev[0][1+i]=-40+5*i;
	      ev[1*i][1+i]=-40+10*i;
	    }
	  }
	  if(b[7][0]==color){
	    for(i=0;i&lt;4;i++){
	      ev[6-i][0]=40-10*i;
	      ev[7][1+i]=40-10*i;
	      ev[6-i][1+i]=10-i;
	    }
	  }
	  if(b[0][7]==color){
	    for(i=0;i&lt;4;i++){
	      ev[1+i][7]=40-10*i;
	      ev[0][6-i]=40-10*i;
	      ev[1+i][6-i]=10-i;
	    }
	  }
	  if(b[7][7]==color){
	    for(i=0;i&lt;4;i++){
	      ev[6-i][7]=40-10*i;
	      ev[7][6-i]=40-10*i;
	      ev[6-i][6-i]=10-i;
	    }
	  }
	  if(b[0][0]==color){
	    for(i=0;i&lt;4;i++){
	      ev[1+i][0]=40-10*i;
	      ev[0][1+i]=40-10*i;
	      ev[1*i][1+i]=10-i;
	    }
	  }
	  while(1){
	    //ストックする．
	    for(y=0;y&lt;HEIGHT;y++){
	      for(x=0;x&lt;WIDTH;x++){
	        c[y][x]=b[y][x];
	      }
	    }
	    countAI_=-100;countP_=100;
	    countAI=0;
	    if(count&lt;100){
	      //序盤:相手に多く取らせる
	      for(y=0;y&lt;HEIGHT;y++){
	        for(x=0;x&lt;WIDTH;x++){
	          if(isputtable_investigate(y,x,color)==ok){
	            put_investigate(y,x,color);
	            countAI=0;countP=0;
	            for(i=0;i&lt;HEIGHT;i++){
	              for(j=0;j&lt;WIDTH;j++){
	                if(c[i][j]==color){
	                  countAI=countAI+ev[i][j];
	                }
	                else if(c[i][j]==other){
	                  countP=countP+ev[i][j];
	                }
	              }
	            }
	            if(countAI_&lt;countAI){
	              countAI_=countAI;
	              printf(&quot;countP=%d\tcountAI=%d\n&quot;,countP,countAI_);
	              n=y;m=x;
	            }
	          }
	          countAI=0;countP=0;
	          for(r=0;r&lt;HEIGHT;r++){
	            for(l=0;l&lt;WIDTH;l++){
	              c[r][l]=b[r][l];
	            }
	          }
	        }
	      }
	    }
	    put(n,m,color);
	    printf(&quot;COMが(%d,%d)に石置いた．\n&quot;,n,m);
	    break;
	  }

	}

	//戦況表示
	void halfway(){
	  int x,y;
	  int white_count,black_count;
	  //盤上の石の数カウント
	  white_count=black_count=0;
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      if(b[y][x]==white){
	        white_count++;
	      }
	      else if(b[y][x]==black){
	        black_count++;
	      }
	    }
	  }
	  printf(&quot;(黒:白)=(%d:%d)\n&quot;,black_count,white_count);
	}

	//結果表示
	void result(){
	  int x,y;
	  int white_count,black_count;
	  //盤上の石の数カウント
	  white_count=black_count=0;
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      if(b[y][x]==white){
	        white_count++;
	      }
	      else if(b[y][x]==black){
	        black_count++;
	      }
	    }
	  }
	  //カウント数に応じて結果表示
	  if(black_count&gt;white_count){
	    printf(&quot;あなたの勝ち&quot;);
	  }
	  else if(black_count&lt;white_count){
	    printf(&quot;お前の負け&quot;);
	  }
	  else{
	    printf(&quot;引き分け&quot;);
	  }
	  printf(&quot;(黒:白)=(%d:%d)\n&quot;,black_count,white_count);
	}

	//次の石の色の決定
	COLOR nextcolor(COLOR now){
	  COLOR next;
	  int x,y;
	  //まず，次の石を他方の色に設定
	  if(now==white){
	    next=black;
	  }
	  else{
	    next=white;
	  }
	  //次の色の石が置けるか確認
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      if(isputtable(x,y,next)==ok){
	        return next;
	      }
	    }
	  }
	  //他方の色の石がおけない時，元の石の色が置けるか否か
	  //次の色の石が置けるか確認
	  for(y=0;y&lt;HEIGHT;y++){
	    for(x=0;x&lt;WIDTH;x++){
	      if(isputtable(x,y,now)==ok){
	        return now;
	      }
	    }
	  }
	  return empty;
	}

	//先攻後攻決定のためのじゃんけん
	PUT jankenn_handable(int n){
	  if(0&lt;=n&amp;&amp;n&lt;3){
	    return ok;
	  }
	  else{
	    return ng;
	  }
	}
	int jankenn(){
	  int n,m;
	  printf(&quot;順番決めのじゃんけんをする．\n&quot;);
	  while(1){
	    printf(&quot;グー:0 チョキ:1 パー:2 を入力&quot;);
	    while(1){
	      scanf(&quot;%d&quot;,&amp;n);
	      if(jankenn_handable(n)==ok){
	        break;
	      }
	      printf(&quot;誤入力\n&quot;);
	    }

	    m=rand()%3;
	    printf(&quot;あなた:%d COM:%d\n&quot;,n,m);
	    if(n==0){
	      if(m==1){
	        printf(&quot;あなたが先攻\n&quot;);
	        return 2;
	      }
	      else if(m==2){
	        printf(&quot;あなたが後攻\n&quot;);
	        return 3;
	      }
	    }
	    else if(n==1){
	      if(m==2){
	        printf(&quot;あなたが先攻\n&quot;);
	        return 2;
	      }
	      else if(m==0){
	        printf(&quot;あなたが後攻\n&quot;);
	        return 3;
	      }
	    }
	    else if(n==2){
	      if(m==0){
	        printf(&quot;あなたが先攻\n&quot;);
	        return 2;
	      }
	      else if(m==1){
	        printf(&quot;あなたが後攻\n&quot;);
	        return 3;
	      }
	    }
	  }

	}

	int main(){
	  int n,count;
	  COLOR now,next;
	  count=0;
	  //じゃんけん
	  n=jankenn();
	  //盤の初期化
	  init();
	  display();
	  //最初に置く石の色
	  if(n==2){
	    now=black;
	  }
	  else{
	    now=white;
	  }

	  //決着つくまでループ
	  while(1){
	    count++;
	    if(now==black){
	      play(now);
	    }
	    else if(now==white){
	      com4(now,count);
	    }
	    //石を置いた後の盤表示
	    display();
	    //現在の戦況
	    halfway();
	    //次のターンに置く石の色決定
	    next=nextcolor(now);
	    if(next==now){
	      printf(&quot;置ける場所ないのでスキップ\n&quot;);
	    }
	    else if(next==empty){
	      printf(&quot;試合終了\n&quot;);
	      result();
	      return 0;
	    }
	    now=next;
	  }
	  return 0;
	}
</pre></code>
				</div>
			</article>
		</section>
	</div><!-- / content -->


</div>
<!-- / wrapper -->

<footer id="footer">
	<p id="copyright">Copyright &copy; Sample Company All rights Reserved. Design by <a href="http://f-tpl.com" target="_blank" rel="nofollow">http://f-tpl.com</a>
</footer>
<!-- / footer -->

</body>
</html>
